remove all bookmarks - Done
remove all logins - Done
remove all personal contents - Done
make sure the personal content is not available - Done
Check pc backup and delete from cloud - Done
sync mozila - Done
sync chrome - Done
remove the cloud backup - Done
take aria screenshots - Done
take mail dumps - Done
rws dumps - Done
slc15bnk dumps - Done
laptop dumps - Done
take last 3 payslips - Done
take shell script and python.. important files - Done
Asks for feedback from team mates - Done
letter from manager for future - Done
https://my.oracle.com/site/mktg/creative/templates/stationery/letterhead/cnt470989.htm
----------
wjat is the advantage of the approach
what is the down side of the approach
what is the performance implicaton
what are the work arounds
what is the usabilty impact
what are the other options available in pipeline
how to approach the problem
what is the round trip implications
can we do anything in parallel
what are the driving for going for the approach
can we expose as a service
take a decision and dont compromise on quality
dont delay things
review the progress regularly
plan properly
-------------
Ask for focus areas
Ask for some of the internal project details
weekly meetings to track progress
Monthly meeting for performance feedback
log work in excel
Think all scenario's
look for alternatives
think for long vision how
think out of the box
take a deeper analysis of the issue
Create automation scripts
    automate everything if possible
Test efficiently and covering all the scenarios
do unit testing
integration testing
Plan and time management
Quit checking gmails or facebook
reduce pantry or talking time
Start learning - python, anaconda, spark sql, hive sql
filter mails
Remember Question Words - [What, Why, How, Whom, When, Whose, Where, Who, How much, How many]
less eating and good sleep
What went well and what did bad

--------------------------------------
Qualities of Prinicipal
    Set clear objectives
    Give clear assigned tasks to Engineers
    set reasonable expectations
    remove obstacles
    listen and cultivate strong relationships
    care for the team
    be accessible always
    Have a good debugging skills
    Know when not to do things
    Mentor others, lead by example
    review code meticluously
    communicate complex technical ideas efficiently
    specialize in something
    admit what you do not know

--------------------------------------
Duties and Responsibilities

Provide technical guidance in software design and development activities.
Assist in maintenances and upgrades of existing software applications.
Participate in design reviews and recommend improvements.
Provide support in all phases of SDLC and ensure to deliver high-quality products.
Provide trainings and mentor other Engineers when required.
Analyze and troubleshoot application issues in a timely fashion.
Develop most effective technical solutions to meet business requirements.
Work with other Engineers in planning, prioritizing and executing assigned tasks within deadlines.
Assist in risk assessment and mitigation activities.
Attend team meetings to communicate project status and discuss about new ideas and any issues.
Recommend new technologies to ensure quality and productivity.
Assist in technical audits and make sure to implement audit recommendations.
Make business presentations to management when needed.
Work with QA team in preparing test cases, plans and procedures.

code review of other developers' work
making bigger technical design/architectural decisions and analyses
mentoring of junior developers
performance evaluation of junior developers
responsibility over more projects/systems/modules
check if something needs to be done, analyze if that needs to be done in other places applications


code review checklists
-----------------------
Am I able to understand the code
is it well written
is the code duplicated more than once
can i unit test easily for possible issue isolation
is the function or class is too big, modularize
    is this code scalable
    is this code performant
    is security taken care
    is code takes care of not functional requirements
    code coverage
    unit tests
    is code follows defined Architecture

check for GRASP
    Controller, Creator, Indirection, information expert, high cohesion, low coupling, polymorphism,protected variations, pure fabrications
check for SOLID 
    Single responsibility, 
    Open for extension and closed for modification
    Liskovs substitution for interface
    Interface segregation
    Dependancy inversion



-----------------------

    Principle 1: Design for Many
    Principle 2: Service-Oriented Architecture Beats Monolithic Application
    Principle 3: Monitor Everything
    Practice 1: Canary Deployments
    Practice 2: Distributed Clock
    Practice 3: Automate To Assist, Not To Control

Availability – Operational characteristic of a system where it is always ready to handle requests.
Scalability – The ability of a system to increase its capacity to handle more load. This could be achieved by adding more servers to a cluster.
Performance – Speed at which a system is able to handle requests.
Cost – Total cost of ownership of the system. This could include hardware, software, development, testing, hosting, and cloud infrastructure.
Manageability – Maintenance, update, migration, scaling, and diagnostic should all be manageable.
Reliability – Able to adapt to the load and respond properly during exceptional conditions.
Heterogeneity – Ability to support a variety of devices and protocols.
Fault Tolerance and Failure Management – Systems designed with an expectation of failure will make them more fault tolerant.
Concurrency – When multiple parts work at the same time (a given for distributed systems).
Migration and Load Balancing – Closely related to reliability, fault tolerance, and failure management.
Security – Ensuring proper authorization and authentication between the users and components of the system is key ensuring the confidentiality and integrity of the data.
Composability and Modularity – Many small subsystems and modules forming a larger system in a way that can be configured and reused in different ways


Scalability Design Principles

    Avoid the single point of failure. 
    Scale horizontally, not vertically. 
    Push work as far away from the core as possible. 
    API first. 
    Cache everything, always.
    Provide as fresh as needed data.
    Design for maintenance and automation.
    Asynchronous rather than synchronous.
    Strive for statelessness. 
    This too shall fail. 


    ----------------
    Debugging steps

    ecid
    request id
    trace
    stack trace
    thread dump
    strace
    dmesg
    proc/pid/thread
-----------
new hire induction - orientation
http://learnxinyminutes.com/
