#Find Length of a Linked List (Iterative and Recursive)
* iterate with the counter
#delete the node if the node is given
* keep track of the node - node.next is the key
* then node.next = node.next.next
#search an element in a tree
* see if the element is equal to the key
#Swap nodes in a linked list without swapping data
* store prev next of 1st node
* store prev next of the second node
* scap the pointers
#Write a function to get Nth node in a Linked List
* loop through and increment if it matches then return that
#print the middle of the linked List
* fast and slow pointers
#nth node from the end of the List
* calculate the length and then pass again for the len -key
* two pointers wuth key as distance
#delete the linked list node if node is given
* copy the next to this node
* delete the next node
#delete the linked list node if the head is given
* iterate and locate and change the pointers
#detect the loop in a linked list
* fast and slow pointer then move around to see when fast and slow meets
#Reverse a linked list
* have prev pointer , store the current , next and next next
#insert in a sorted linked list
* use two pointer to store the prev and next inbetween which the node is to be inserted
#remove duplicates
* iterate to see if the next next is same as that of the node
* then move ahead with the pointer
#move last element to the front of the list
* make second last as last
* head as the next node
* take the next node and points as the head
#palindrome check for linked list
* reverse and see if its equal
* use stack
#Rotate a linked list
* move the pointer up to k as null
* next as the head
* head is added as next of new head
#Add two numbers
* carry
* sum
