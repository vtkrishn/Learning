Array / String Technique

two pointer approach - close to each other - o(n)
two pointer approach - opposite to each other - o(n)
sliding window - o(n)
find mid point and proceed - o(n) - logn
Running max or min - o(n)
compare last and first element
Reverse logic (from the result derive back to original)
Count Map - extra space
Bit wise - o(n) ~ o(1)
Sort if it helps - o(nlogn)
Additional array if needed - space usage
Use generic formula if available - O(1) most of the cases
Set Flag and flip each time - o(n)
Multiple pass - o(n) time consuming
Pre compute if needed - space and time for lookups
Binary Search for sorted array - logn
Reverse if needed - o(n)
modify the input array itslf - o(n)
see if u can use other data structures like stack or queue - space extra

Linked List Techniques

store next or previous pointer - o(n) , space
two pointer approach - fast and slow - o(n)
think recursively - o(n)
try combinations - Doubly linked list , circular linked list for problems

Tree
recursive approach
DFS - try stack
BFS - try queue

Graph - DFS, BFS, Bidriectional
